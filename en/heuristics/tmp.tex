\section{Choice of Plan}
In this section, firstly, we introduce the $\emph{A* algorithm}$ which has been learned from in our algorithm; then we explain and discuss our heuristics when choosing a HTN in $\emph{openList}$.

\subsection{Search for a solution}
The goal of our first heuristic is to guide the algorithm to find a solution.

As in line 7 of \autoref{algo1}, each HTN in $\emph{openList}$ possibly leads to a solution, we need to choose one of them to do further planning. The sooner we find a solution and return, the less we search. Therefore, the chosen HTN should be the one which is the most likely to be a solution.

In \autoref{algo2}, each time after we have refined a compound task, all the constraints in the obtained HTN are checked, if there exists any unsatisfiable constraint, the obtained HTN will not be added in $\emph{openList}$, in another word, it will not be considered any more.
we assume that the possibility to find unsatisfiable constraints through each refining is the same

Our heuristic takes the performed refining depth and the left refining into consideration. 
\begin{itemize}
\item[$\bullet$] \textbf{Refining Depth}\\
If a HTN is in $\emph{openList}$, it is to say that all the performed refining on the HTN has not lead to any unsatisfiable constraint (In \autoref{algo2}, all the constraints of a compound task are checked right after it have been refined). In another word, the past refining has succeeded in current perspective.
\item[$\bullet$] \textbf{Left Refining}\\
Each refining may cause unsatisfiable constraints, the less refining left to do in a HTN, the more chance we get a solution from it.

A HTN with a deep refining depth (i.e. which has been refined many times) and with few further refining to do is more likely to be a solution.

\subsubsection*{A Naive Approach}

\subsubsection*{An Admissible Search}

Considering the Constraints










 A possible solution is to increase compound tasksâ€™ weights with dynamic weighting A*, dynamic weighting A* is a variant of A*, its cost function is: f(p) $=$ g(p) + w(p) * h(p). We can use a general weight for all the compound tasks, the general weight can be the average length of refinements of all methods in the domain.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 A compound task may have infinite implementations, for example, a recursive compound task like $\emph{reverse}$ in blocksWorld. Another example is as the follows:

$(:method A\\
		:parameters	()\\
		:precondition(p1)\\
		:expansion	(\\
		    (tag a (B))\\
		    (tag b (do\_something))\\
		)\\
		:constraints()\\
)$\\

$(:method A\\
		:parameters	()\\
		:precondition(p2)\\
		:expansion	(\\
		    (tag c (do\_nothing))\\
		)\\
		:constraints()\\
)$\\

$(:method B\\
		:parameters	()\\
		:precondition(p3)\\
		:expansion	(\\
		    (tag a (A))\\
		    (tag b (do\_something))\\
		)\\
		:constraints()\\
)$\\

$(:method B\\
		:parameters	()\\
		:precondition(p4)\\
		:expansion	(\\
		    (tag c (do\_nothing))\\
		)\\
		:constraints()\\
)$\\